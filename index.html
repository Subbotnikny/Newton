<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Колыбель Ньютона</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background: #0a0a1f;
            color: #fff;
            margin: 20px;
        }
        canvas {
            border: 1px solid #444;
            background: #1a1a2e;
            display: block;
            margin: 0 auto;
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            margin: 0 5px;
            font-size: 16px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #357abd;
        }
        .note {
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <h1>Колыбель Ньютона</h1>
    <canvas id="canvas" width="600" height="400"></canvas>
    <div class="controls">
        <button onclick="startSwing(1)">Качать 1 шар</button>
        <button onclick="startSwing(2)">Качать 2 шара</button>
        <button onclick="reset()">Сброс</button>
    </div>
    <div class="note">Перетаскивай шары мышкой или пальцем. Бесконечная анимация без затухания.</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const numBalls = 5;
        const ballRadius = 20;
        const stringLength = 150;
        const frameY = 50;
        const spacing = ballRadius * 2 + 2;
        const centerX = canvas.width / 2;

        let balls = [];
        let dragging = null;

        class Ball {
            constructor(index) {
                this.index = index;
                this.anchorX = centerX + (index - 2) * spacing;
                this.anchorY = frameY;
                this.angle = 0;
                this.velocity = 0;
                this.mass = 1;
                this.stringLength = stringLength;
            }

            get x() {
                return this.anchorX + Math.sin(this.angle) * this.stringLength;
            }

            get y() {
                return this.anchorY + Math.cos(this.angle) * this.stringLength;
            }

            update(dt) {
                const gravity = 0.5;
                const damping = 1;  // Без затухания — бесконечно
                let acceleration = (-gravity / this.stringLength) * Math.sin(this.angle);
                this.velocity += acceleration * dt;
                this.velocity *= damping;
                this.angle += this.velocity * dt;
            }

            draw() {
                ctx.strokeStyle = '#aaa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.anchorX, this.anchorY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();

                ctx.fillStyle = '#ffd700';  // Золотой цвет шаров
                ctx.beginPath();
                ctx.arc(this.x, this.y, ballRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.beginPath();
                ctx.arc(this.x - 5, this.y - 5, ballRadius / 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function detectCollisions() {
            for (let i = 0; i < balls.length - 1; i++) {
                const b1 = balls[i];
                const b2 = balls[i + 1];
                const dx = b2.x - b1.x;
                const dy = b2.y - b1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < ballRadius * 2) {
                    // Упругая передача импульса
                    const temp = b1.velocity;
                    b1.velocity = b2.velocity;
                    b2.velocity = temp;
                }
            }
        }

        function animate() {
            const dt = 0.5;
            balls.forEach(ball => {
                if (dragging !== ball) {
                    ball.update(dt);
                }
            });
            detectCollisions();
            draw();
            requestAnimationFrame(animate);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(50, frameY);
            ctx.lineTo(canvas.width - 50, frameY);
            ctx.stroke();
            balls.forEach(ball => ball.draw());
        }

        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            for (let ball of balls) {
                const dx = mx - ball.x;
                const dy = my - ball.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < ballRadius) {
                    dragging = ball;
                    ball.velocity = 0;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', e => {
            if (dragging) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const dx = mx - dragging.anchorX;
                const dy = my - dragging.anchorY;
                dragging.angle = Math.atan2(dx, dy);
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const mx = touch.clientX - rect.left;
            const my = touch.clientY - rect.top;
            for (let ball of balls) {
                const dx = mx - ball.x;
                const dy = my - ball.y;
                if (Math.sqrt(dx * dx + dy * dy) < ballRadius) {
                    dragging = ball;
                    ball.velocity = 0;
                    break;
                }
            }
        });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (dragging) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const mx = touch.clientX - rect.left;
                const my = touch.clientY - rect.top;
                const dx = mx - dragging.anchorX;
                const dy = my - dragging.anchorY;
                dragging.angle = Math.atan2(dx, dy);
            }
        });

        canvas.addEventListener('touchend', () => {
            dragging = null;
        });

        canvas.addEventListener('touchcancel', () => {
            dragging = null;
        });

        function init() {
            balls = [];
            for (let i = 0; i < numBalls; i++) {
                balls.push(new Ball(i));
            }
            // Автоматический запуск с 1 шаром
            startSwing(1);
        }

        function startSwing(count) {
            reset();
            for (let i = 0; i < count; i++) {
                balls[i].angle = -0.6;  // Отводим влево
            }
        }

        function reset() {
            balls.forEach(ball => {
                ball.angle = 0;
                ball.velocity = 0;
            });
        }

        init();
        animate();
    </script>
</body>

</html>
